package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"plutus-backend/graph/generated"
	"plutus-backend/graph/model"
	"sort"

	"github.com/lib/pq"
)

// CreateEnquiry is the resolver for the createEnquiry field.
func (r *mutationResolver) CreateEnquiry(ctx context.Context, productID string, productName string, productBrand string, productImage string, contact string) (bool, error) {
	query := `INSERT INTO enquiries (product_id, product_name, product_brand, product_image, contact) VALUES ($1, $2, $3, $4, $5)`
	_, err := r.DB.Exec(query, productID, productName, productBrand, productImage, contact)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Sneakers is the resolver for the sneakers field.
func (r *queryResolver) Sneakers(ctx context.Context, brand *string, size *string, sortOrder *string, minPrice *float64, maxPrice *float64, search *string, limit *int, offset *int) ([]*model.Sneaker, error) {
	query := `
		SELECT id, brand, product_name, size_prices, images, sold_out, product_link, seller_name, seller_url
		FROM sneakers
		WHERE 1=1
	`
	if brand != nil && *brand != "" {
		// Use direct brand comparison for better performance
		query += fmt.Sprintf(" AND LOWER(brand) = LOWER('%s')", *brand)
	}
	if size != nil && *size != "" {
		query += fmt.Sprintf(" AND size_prices::text ILIKE '%%%s%%'", *size)
	}
	if search != nil && *search != "" {
		query += fmt.Sprintf(" AND (brand ILIKE '%%%s%%' OR product_name ILIKE '%%%s%%')", *search, *search)
	}
	// Sorting
	if sortOrder != nil && (*sortOrder == "asc" || *sortOrder == "desc") {
		query += " ORDER BY (SELECT MIN((sp->>'price')::float) FROM jsonb_array_elements(size_prices) sp) " + *sortOrder
	}
	// Pagination
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}
	if offset != nil {
		query += fmt.Sprintf(" OFFSET %d", *offset)
	}

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var sneakers []*model.Sneaker

	for rows.Next() {
		var id, brandVal, productName, productLink string
		var sizePricesRaw []byte
		var images []string
		var soldOut bool
		var sellerName, sellerUrl *string

		if err := rows.Scan(&id, &brandVal, &productName, &sizePricesRaw, pq.Array(&images), &soldOut, &productLink, &sellerName, &sellerUrl); err != nil {
			return nil, err
		}

		var sizePrices []model.SizePrice
		if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
			return nil, err
		}

		var sizePricesPtr []*model.SizePrice
		for _, sp := range sizePrices {
			spCopy := sp
			sizePricesPtr = append(sizePricesPtr, &spCopy)
		}

		sneakers = append(sneakers, &model.Sneaker{
			ID:          id,
			Brand:       brandVal,
			ProductName: productName,
			SizePrices:  sizePricesPtr,
			Images:      images,
			SoldOut:     soldOut,
			SellerName:  sellerName,
			SellerURL:   sellerUrl,
			ProductLink: productLink,
		})
	}
	return sneakers, nil
}

// Sneaker is the resolver for the sneaker field.
func (r *queryResolver) Sneaker(ctx context.Context, id string) (*model.Sneaker, error) {
	query := `SELECT id, brand, product_name, size_prices, images, sold_out, product_link, seller_name, seller_url FROM sneakers WHERE id = $1`
	row := r.DB.QueryRow(query, id)
	var idVal, brandVal, productName, productLink string
	var sizePricesRaw []byte
	var images []string
	var soldOut bool
	var sellerName, sellerUrl *string
	if err := row.Scan(&idVal, &brandVal, &productName, &sizePricesRaw, pq.Array(&images), &soldOut, &productLink, &sellerName, &sellerUrl); err != nil {
		if err == sql.ErrNoRows {
			// Return a more descriptive error for missing products
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, err
	}
	var sizePrices []model.SizePrice
	if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
		return nil, err
	}
	var sizePricesPtr []*model.SizePrice
	for _, sp := range sizePrices {
		spCopy := sp
		sizePricesPtr = append(sizePricesPtr, &spCopy)
	}
	return &model.Sneaker{
		ID:          idVal,
		Brand:       brandVal,
		ProductName: productName,
		SizePrices:  sizePricesPtr,
		Images:      images,
		SoldOut:     soldOut,
		SellerName:  sellerName,
		SellerURL:   sellerUrl,
		ProductLink: productLink, // <-- Added this line
	}, nil
}

// Watches is the resolver for the watches field.
func (r *queryResolver) Watches(ctx context.Context, brand *string, color *string, gender *string, sortOrder *string, minPrice *float64, maxPrice *float64, search *string, limit *int, offset *int) ([]*model.Watch, error) {
	query := `
		SELECT id, brand, name, color, sale_price, market_price, images, link, seller_name, seller_url, gender
		FROM watches
		WHERE 1=1
	`
	if brand != nil && *brand != "" {
		// Use direct brand comparison for better performance
		query += fmt.Sprintf(" AND LOWER(brand) = LOWER('%s')", *brand)
	}
	if color != nil && *color != "" {
		query += fmt.Sprintf(" AND color ILIKE '%%%s%%'", *color)
	}
	if gender != nil && *gender != "" {
		query += fmt.Sprintf(" AND gender ILIKE '%%%s%%'", *gender)
	}
	if search != nil && *search != "" {
		query += fmt.Sprintf(" AND (name ILIKE '%%%s%%' OR brand ILIKE '%%%s%%')", *search, *search)
	}
	if minPrice != nil && *minPrice > 0 {
		query += fmt.Sprintf(" AND sale_price >= %f", *minPrice)
	}
	if maxPrice != nil && *maxPrice > 0 {
		query += fmt.Sprintf(" AND sale_price <= %f", *maxPrice)
	}

	// Sorting
	if sortOrder != nil && (*sortOrder == "asc" || *sortOrder == "desc") {
		query += " ORDER BY sale_price " + *sortOrder
	}

	// Pagination at database level
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}
	if offset != nil {
		query += fmt.Sprintf(" OFFSET %d", *offset)
	}

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var watches []*model.Watch
	for rows.Next() {
		var w model.Watch
		var sellerName, sellerUrl *string
		var genderVal sql.NullString
		if err := rows.Scan(&w.ID, &w.Brand, &w.Name, &w.Color, &w.SalePrice, &w.MarketPrice, pq.Array(&w.Images), &w.Link, &sellerName, &sellerUrl, &genderVal); err != nil {
			return nil, err
		}
		w.SellerName = sellerName
		w.SellerURL = sellerUrl
		if genderVal.Valid {
			w.Gender = &genderVal.String
		}
		watches = append(watches, &w)
	}

	return watches, nil
}

// Watch is the resolver for the watch field.
func (r *queryResolver) Watch(ctx context.Context, id string) (*model.Watch, error) {
	query := `SELECT id, brand, name, color, sale_price, market_price, images, link, seller_name, seller_url, gender FROM watches WHERE id = $1`
	row := r.DB.QueryRow(query, id)
	var w model.Watch
	var sellerName, sellerUrl *string
	var genderVal sql.NullString
	if err := row.Scan(&w.ID, &w.Brand, &w.Name, &w.Color, &w.SalePrice, &w.MarketPrice, pq.Array(&w.Images), &w.Link, &sellerName, &sellerUrl, &genderVal); err != nil {
		if err == sql.ErrNoRows {
			// Return a more descriptive error for missing products
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, err
	}
	w.SellerName = sellerName
	w.SellerURL = sellerUrl
	if genderVal.Valid {
		w.Gender = &genderVal.String
	}
	return &w, nil
}

// Perfumes is the resolver for the perfumes field.
func (r *queryResolver) Perfumes(ctx context.Context, brand *string, fragranceFamily *string, concentration *string, subcategory *string, size *string, sortOrder *string, minPrice *float64, maxPrice *float64, search *string, limit *int, offset *int) ([]*model.Perfume, error) {
	query := `
		SELECT id, brand, title, fragrance_family, variants, images, url, seller_name, seller_url
		FROM perfumes
		WHERE 1=1
	`
	if brand != nil && *brand != "" {
		// Use direct brand comparison for better performance
		query += fmt.Sprintf(" AND LOWER(brand) = LOWER('%s')", *brand)
	}
	if fragranceFamily != nil && *fragranceFamily != "" {
		query += fmt.Sprintf(" AND fragrance_family ILIKE '%%%s%%'", *fragranceFamily)
	}
	if size != nil && *size != "" {
		query += fmt.Sprintf(" AND variants::text ILIKE '%%%s%%'", *size)
	}
	if search != nil && *search != "" {
		query += fmt.Sprintf(" AND (title ILIKE '%%%s%%' OR brand ILIKE '%%%s%%')", *search, *search)
	}

	// Pagination at database level
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}
	if offset != nil {
		query += fmt.Sprintf(" OFFSET %d", *offset)
	}

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var perfumes []*model.Perfume
	for rows.Next() {
		var p model.Perfume
		var variantsRaw []byte
		var sellerName, sellerUrl *string
		if err := rows.Scan(&p.ID, &p.Brand, &p.Title, &p.FragranceFamily, &variantsRaw, pq.Array(&p.Images), &p.URL, &sellerName, &sellerUrl); err != nil {
			return nil, err
		}
		if err := json.Unmarshal(variantsRaw, &p.Variants); err != nil {
			return nil, err
		}
		p.SellerName = sellerName
		p.SellerURL = sellerUrl
		perfumes = append(perfumes, &p)
	}

	return perfumes, nil
}

// Perfume is the resolver for the perfume field.
func (r *queryResolver) Perfume(ctx context.Context, id string) (*model.Perfume, error) {
	query := `SELECT id, brand, title, fragrance_family, concentration, subcategory, variants, images, url, seller_name, seller_url FROM perfumes WHERE id = $1`
	row := r.DB.QueryRow(query, id)
	var p model.Perfume
	var sellerName, sellerUrl *string
	if err := row.Scan(&p.ID, &p.Brand, &p.Title, &p.FragranceFamily, &p.Concentration, &p.Subcategory, pq.Array(&p.Variants), pq.Array(&p.Images), &p.URL, &sellerName, &sellerUrl); err != nil {
		if err == sql.ErrNoRows {
			// Return a more descriptive error for missing products
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, err
	}
	p.SellerName = sellerName
	p.SellerURL = sellerUrl
	return &p, nil
}

// Accessories is the resolver for the accessories field.
func (r *queryResolver) Accessories(ctx context.Context, brand *string, subcategory *string, gender *string, size *string, sortOrder *string, minPrice *float64, maxPrice *float64, search *string, limit *int, offset *int) ([]*model.Accessory, error) {
	query := `
		SELECT id, brand, product_name, subcategory, gender, size_prices, images, in_stock, product_link, seller_name, seller_url
		FROM accessories
		WHERE 1=1
	`
	if brand != nil && *brand != "" {
		// Use direct brand comparison for better performance
		query += fmt.Sprintf(" AND LOWER(brand) = LOWER('%s')", *brand)
	}
	if subcategory != nil && *subcategory != "" {
		query += fmt.Sprintf(" AND subcategory ILIKE '%%%s%%'", *subcategory)
	}
	if gender != nil && *gender != "" {
		query += fmt.Sprintf(" AND gender ILIKE '%%%s%%'", *gender)
	}
	if size != nil && *size != "" {
		query += fmt.Sprintf(" AND size_prices::text ILIKE '%%%s%%'", *size)
	}
	if search != nil && *search != "" {
		query += fmt.Sprintf(" AND (product_name ILIKE '%%%s%%' OR brand ILIKE '%%%s%%')", *search, *search)
	}

	// Pagination at database level
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}
	if offset != nil {
		query += fmt.Sprintf(" OFFSET %d", *offset)
	}

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accessories []*model.Accessory
	for rows.Next() {
		var id, brandVal, productName, subcategoryVal, genderVal, productLink string
		var sizePricesRaw []byte
		var images []string
		var inStock bool
		var sellerName, sellerUrl *string

		if err := rows.Scan(&id, &brandVal, &productName, &subcategoryVal, &genderVal, &sizePricesRaw, pq.Array(&images), &inStock, &productLink, &sellerName, &sellerUrl); err != nil {
			return nil, err
		}

		var sizePrices []model.SizePrice
		if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
			return nil, err
		}
		var sizePricesPtr []*model.SizePrice
		for _, sp := range sizePrices {
			spCopy := sp
			sizePricesPtr = append(sizePricesPtr, &spCopy)
		}
		accessories = append(accessories, &model.Accessory{
			ID:          id,
			Brand:       brandVal,
			ProductName: productName,
			Subcategory: subcategoryVal,
			Gender:      genderVal,
			SizePrices:  sizePricesPtr,
			Images:      images,
			InStock:     inStock,
			ProductLink: productLink,
			SellerName:  sellerName,
			SellerURL:   sellerUrl,
		})
	}

	return accessories, nil
}

// Accessory is the resolver for the accessory field.
func (r *queryResolver) Accessory(ctx context.Context, id string) (*model.Accessory, error) {
	query := `SELECT id, brand, product_name, subcategory, gender, size_prices, images, in_stock, product_link, seller_name, seller_url FROM accessories WHERE id = $1`
	row := r.DB.QueryRow(query, id)
	var a model.Accessory
	var sizePricesRaw []byte
	var sellerName, sellerUrl *string
	if err := row.Scan(&a.ID, &a.Brand, &a.ProductName, &a.Subcategory, &a.Gender, &sizePricesRaw, pq.Array(&a.Images), &a.InStock, &a.ProductLink, &sellerName, &sellerUrl); err != nil {
		if err == sql.ErrNoRows {
			// Return a more descriptive error for missing products
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, err
	}
	var sizePrices []model.SizePrice
	if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
		return nil, err
	}
	var sizePricesPtr []*model.SizePrice
	for _, sp := range sizePrices {
		spCopy := sp
		sizePricesPtr = append(sizePricesPtr, &spCopy)
	}
	a.SizePrices = sizePricesPtr
	a.SellerName = sellerName
	a.SellerURL = sellerUrl
	return &a, nil
}

// Apparel is the resolver for the apparel field.
func (r *queryResolver) Apparel(ctx context.Context, brand *string, subcategory *string, gender *string, size *string, sortOrder *string, minPrice *float64, maxPrice *float64, search *string, limit *int, offset *int) ([]*model.Apparel, error) {
	query := `
		SELECT id, brand, product_name, subcategory, gender, size_prices, images, in_stock, product_link, seller_name, seller_url
		FROM apparel
		WHERE 1=1
	`
	if brand != nil && *brand != "" {
		// Use direct brand comparison for better performance
		query += fmt.Sprintf(" AND LOWER(brand) = LOWER('%s')", *brand)
	}
	if subcategory != nil && *subcategory != "" {
		query += fmt.Sprintf(" AND subcategory ILIKE '%%%s%%'", *subcategory)
	}
	if gender != nil && *gender != "" {
		query += fmt.Sprintf(" AND gender ILIKE '%%%s%%'", *gender)
	}
	if size != nil && *size != "" {
		query += fmt.Sprintf(" AND size_prices::text ILIKE '%%%s%%'", *size)
	}
	if search != nil && *search != "" {
		query += fmt.Sprintf(" AND (product_name ILIKE '%%%s%%' OR brand ILIKE '%%%s%%')", *search, *search)
	}

	// Pagination at database level
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}
	if offset != nil {
		query += fmt.Sprintf(" OFFSET %d", *offset)
	}

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var apparels []*model.Apparel
	for rows.Next() {
		var id, brandVal, productName, subcategoryVal, genderVal, productLink string
		var sizePricesRaw []byte
		var images []string
		var inStock bool
		var sellerName, sellerUrl *string

		if err := rows.Scan(&id, &brandVal, &productName, &subcategoryVal, &genderVal, &sizePricesRaw, pq.Array(&images), &inStock, &productLink, &sellerName, &sellerUrl); err != nil {
			return nil, err
		}

		var sizePrices []model.SizePrice
		if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
			return nil, err
		}
		var sizePricesPtr []*model.SizePrice
		for _, sp := range sizePrices {
			spCopy := sp
			sizePricesPtr = append(sizePricesPtr, &spCopy)
		}
		apparels = append(apparels, &model.Apparel{
			ID:          id,
			Brand:       brandVal,
			ProductName: productName,
			Subcategory: subcategoryVal,
			Gender:      genderVal,
			SizePrices:  sizePricesPtr,
			Images:      images,
			InStock:     inStock,
			ProductLink: productLink,
			SellerName:  sellerName,
			SellerURL:   sellerUrl,
		})
	}

	return apparels, nil
}

// ApparelItem is the resolver for the apparelItem field.
func (r *queryResolver) ApparelItem(ctx context.Context, id string) (*model.Apparel, error) {
	query := `SELECT id, brand, product_name, subcategory, gender, size_prices, images, in_stock, product_link, seller_name, seller_url FROM apparel WHERE id = $1`
	row := r.DB.QueryRow(query, id)
	var a model.Apparel
	var sizePricesRaw []byte
	var sellerName, sellerUrl *string
	if err := row.Scan(&a.ID, &a.Brand, &a.ProductName, &a.Subcategory, &a.Gender, &sizePricesRaw, pq.Array(&a.Images), &a.InStock, &a.ProductLink, &sellerName, &sellerUrl); err != nil {
		if err == sql.ErrNoRows {
			// Return a more descriptive error for missing products
			return nil, fmt.Errorf("product with id %s not found", id)
		}
		return nil, err
	}
	var sizePrices []model.SizePrice
	if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
		return nil, err
	}
	var sizePricesPtr []*model.SizePrice
	for _, sp := range sizePrices {
		spCopy := sp
		sizePricesPtr = append(sizePricesPtr, &spCopy)
	}
	a.SizePrices = sizePricesPtr
	a.SellerName = sellerName
	a.SellerURL = sellerUrl
	return &a, nil
}

// AllSneakerBrands is the resolver for the allSneakerBrands field.
func (r *queryResolver) AllSneakerBrands(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT brand FROM sneakers")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var brands []string
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		brands = append(brands, brand)
	}
	return brands, nil
}

// AllSneakerSizes is the resolver for the allSneakerSizes field.
func (r *queryResolver) AllSneakerSizes(ctx context.Context, brand *string) ([]string, error) {
	var rows *sql.Rows
	var err error
	if brand != nil && *brand != "" {
		// Use a simpler brand comparison
		rows, err = r.DB.Query(`SELECT size_prices FROM sneakers WHERE LOWER(brand) = LOWER($1)`, *brand)
	} else {
		rows, err = r.DB.Query(`SELECT size_prices FROM sneakers`)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	sizeSet := make(map[string]struct{})
	for rows.Next() {
		var sizePricesRaw []byte
		if err := rows.Scan(&sizePricesRaw); err != nil {
			return nil, err
		}
		var sizePrices []model.SizePrice
		if err := json.Unmarshal(sizePricesRaw, &sizePrices); err != nil {
			continue // skip bad rows
		}
		for _, sp := range sizePrices {
			if sp.Size != "" {
				sizeSet[sp.Size] = struct{}{}
			}
		}
	}
	var sizes []string
	for s := range sizeSet {
		sizes = append(sizes, s)
	}
	sort.Strings(sizes)
	return sizes, nil
}

// AllWatchBrands is the resolver for the allWatchBrands field.
func (r *queryResolver) AllWatchBrands(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT brand FROM watches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var brands []string
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		brands = append(brands, brand)
	}
	return brands, nil
}

// AllPerfumeBrands is the resolver for the allPerfumeBrands field.
func (r *queryResolver) AllPerfumeBrands(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT brand FROM perfumes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var brands []string
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		brands = append(brands, brand)
	}
	return brands, nil
}

// AllAccessoryBrands is the resolver for the allAccessoryBrands field.
func (r *queryResolver) AllAccessoryBrands(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT brand FROM accessories")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var brands []string
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		brands = append(brands, brand)
	}
	return brands, nil
}

// AllApparelBrands is the resolver for the allApparelBrands field.
func (r *queryResolver) AllApparelBrands(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT brand FROM apparel")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var brands []string
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		brands = append(brands, brand)
	}
	return brands, nil
}

// AllSneakerSubcategories is the resolver for the allSneakerSubcategories field.
func (r *queryResolver) AllSneakerSubcategories(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT subcategory FROM sneakers")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var subcategories []string
	for rows.Next() {
		var subcategory sql.NullString
		if err := rows.Scan(&subcategory); err != nil {
			return nil, err
		}
		if subcategory.Valid {
			subcategories = append(subcategories, subcategory.String)
		}
	}
	return subcategories, nil
}

// AllApparelSubcategories is the resolver for the allApparelSubcategories field.
func (r *queryResolver) AllApparelSubcategories(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT subcategory FROM apparel")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var subcategories []string
	for rows.Next() {
		var subcategory sql.NullString
		if err := rows.Scan(&subcategory); err != nil {
			return nil, err
		}
		if subcategory.Valid {
			subcategories = append(subcategories, subcategory.String)
		}
	}
	return subcategories, nil
}

// AllAccessorySubcategories is the resolver for the allAccessorySubcategories field.
func (r *queryResolver) AllAccessorySubcategories(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT subcategory FROM accessories")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var subcategories []string
	for rows.Next() {
		var subcategory sql.NullString
		if err := rows.Scan(&subcategory); err != nil {
			return nil, err
		}
		if subcategory.Valid {
			subcategories = append(subcategories, subcategory.String)
		}
	}
	return subcategories, nil
}

// AllWatchSubcategories is the resolver for the allWatchSubcategories field.
func (r *queryResolver) AllWatchSubcategories(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT subcategory FROM watches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var subcategories []string
	for rows.Next() {
		var subcategory sql.NullString
		if err := rows.Scan(&subcategory); err != nil {
			return nil, err
		}
		if subcategory.Valid {
			subcategories = append(subcategories, subcategory.String)
		}
	}
	return subcategories, nil
}

// AllPerfumeSubcategories is the resolver for the allPerfumeSubcategories field.
func (r *queryResolver) AllPerfumeSubcategories(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT subcategory FROM perfumes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var subcategories []string
	for rows.Next() {
		var subcategory sql.NullString
		if err := rows.Scan(&subcategory); err != nil {
			return nil, err
		}
		if subcategory.Valid {
			subcategories = append(subcategories, subcategory.String)
		}
	}
	return subcategories, nil
}

// AllApparelGenders is the resolver for the allApparelGenders field.
func (r *queryResolver) AllApparelGenders(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT gender FROM apparel")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var genders []string
	for rows.Next() {
		var gender sql.NullString
		if err := rows.Scan(&gender); err != nil {
			return nil, err
		}
		if gender.Valid {
			genders = append(genders, gender.String)
		}
	}
	return genders, nil
}

// AllAccessoryGenders is the resolver for the allAccessoryGenders field.
func (r *queryResolver) AllAccessoryGenders(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT gender FROM accessories")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var genders []string
	for rows.Next() {
		var gender sql.NullString
		if err := rows.Scan(&gender); err != nil {
			return nil, err
		}
		if gender.Valid {
			genders = append(genders, gender.String)
		}
	}
	return genders, nil
}

// AllWatchGenders is the resolver for the allWatchGenders field.
func (r *queryResolver) AllWatchGenders(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT gender FROM watches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var genders []string
	for rows.Next() {
		var gender sql.NullString
		if err := rows.Scan(&gender); err != nil {
			return nil, err
		}
		if gender.Valid {
			genders = append(genders, gender.String)
		}
	}
	return genders, nil
}

// AllSneakerGenders is the resolver for the allSneakerGenders field.
func (r *queryResolver) AllSneakerGenders(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT gender FROM sneakers")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var genders []string
	for rows.Next() {
		var gender sql.NullString
		if err := rows.Scan(&gender); err != nil {
			return nil, err
		}
		if gender.Valid {
			genders = append(genders, gender.String)
		}
	}
	return genders, nil
}

// AllPerfumeGenders is the resolver for the allPerfumeGenders field.
func (r *queryResolver) AllPerfumeGenders(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT gender FROM perfumes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var genders []string
	for rows.Next() {
		var gender sql.NullString
		if err := rows.Scan(&gender); err != nil {
			return nil, err
		}
		if gender.Valid {
			genders = append(genders, gender.String)
		}
	}
	return genders, nil
}

// AllPerfumeFragranceFamilies is the resolver for the allPerfumeFragranceFamilies field.
func (r *queryResolver) AllPerfumeFragranceFamilies(ctx context.Context) ([]string, error) {
	rows, err := r.DB.Query("SELECT DISTINCT fragrance_family FROM perfumes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var families []string
	for rows.Next() {
		var family sql.NullString
		if err := rows.Scan(&family); err != nil {
			return nil, err
		}
		if family.Valid {
			families = append(families, family.String)
		}
	}
	return families, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
